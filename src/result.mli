(** The result of executing a {!Node} in an {!Ast}. 

    Results are generated by {!Eval.run}. It takes a {!Node.t} list,
    evaluates each one, and generates a {!Result.t} list.

    A {!Result.t} record represents an AST node which has been 
    executed/evaluated. It is basically a copy of a {!Node.t} record, but 
    it executes any commands, captures the exit code, stdout, etc., and 
    adds that captured information to the resulting record. So the 
    {!Result.t} record has the command, plus its execution information.

    Not all types of nodes/results have commands associated with them.
    For instance, {!Token_type.t.Blank} and {!Token_type.t.Comment} nodes
    represent blank lines and lines of commentary respectively. There is
    nothing to do to "evaluate" these types of nodes, so the {!Result.t}
    records for these types of nodes do not have any of the execution 
    information (like exit codes or stdout/stderr) that, say,
    {!Token_type.t.Code} results do. *)

(** Reasons why a particular node would pass or fail. *)
type status =
  | NA
  | NonZeroExit
  | ZeroExit
  | UnexpectedOutput
  | ExpectedOutput

(** A {!Result.t} carries with it a token type {!Token_type.t}, some raw
    [data] (a list of strings from the source file), an optional [cmd] (a
    string to execute in a shell), some optional expected [output] (a list
    of strings the command is expected to produce), some optional [stdout]
    (a list of any strings the command printed to stdout), some optional
    [stderr] (a list of any strings the command printed to stderr), an
    optional [exit_code] (an int) returned by the command, an indicator of
    [success] (a {!Success.t} record), and any optional time [trails] (a
    {!Trials.t} record).

    {!Result.t} records that need not be "executed" -- for example, records
    that represent blank lines or lines of commentary -- are not executed,
    so they will have [None] for all the optional execution information. *)
type t = {
  token: Token_type.t;
  data: string list;
  cmd: string option;
  output: string list option;
  stdout: string list option;
  stderr: string list option;
  exit_code: int option;
  success: Success.t;
  trials: Trials.t option;
}

(** Raised if an invalid node is encountered. *)
exception InvalidNode of string

(** Builds a result record.

    Arguments:
    - A {!Token_type.t} type.
    - A list of raw content/data (the original strings taken from 
    a source file).
    - An optional command (a string) to execute in a shell.
    - An optional list of strings the command is expected to output.
    - An optional list of strings captured from the command's stdout.
    - An optional list of strings captured from the command's stderr.
    - An optional exit code (an int) captured from the command.
    - A {!Success.t} record, indicating if the result succeeded.
    - An optional {!Trials.t} record, if the result was profiled.

    Returns: A {!Result.t} record. 

    Note: this is a general function for building {!Result.t} records.
    There are helper modules below that make creating particular types
    of results easier. For instance, to create a {!Result.t} that 
    represents code, use {!Result.Code.create}. *)
val build : Token_type.t ->
            string list ->
	    string option ->
	    string list option ->
	    string list option ->
	    string list option ->
	    int option ->
	    Success.t ->
	    Trials.t option ->
	    t

(** Get the token type of the result node. *)
val token : t -> Token_type.t

(** Get the raw data of the result node. *)
val data : t -> string list

(** Get the command of a result node. *)
val cmd : t -> string option

(** Get the expected output of a result node. *)
val output : t -> string list option

(** Get the captured stdout of a result node. *)
val stdout : t -> string list option

(** Get the captured stderr of a result node. *)
val stderr : t -> string list option

(** Get the exit code of a result node. *)
val exit_code : t -> int option

(** Get the success of a result node. *)
val success : t -> Success.t

(** Get the trials of a result node. *)
val trials : t -> Trials.t option

(** Checks if a whole set of results is successful. *)
val is_successful : t list -> bool

(** Helps construct {!Token_type.t.Blank} results. *)
module Blank : sig

  (** Creates a {!Result.t} node of type {!Token_type.t.Blank}. 

      Arguments:
      - A list of blank lines (strings) from the original file.

      Returns: a {!Result.t} record. 

      For example, [create [" "; ""; "   "]] will create a {!Result.t}
      node consisting of the three provided lines. *)
  val create : string list -> t

end

(** Helps construct {!Token_type.t.Comment} results. *)
module Comment : sig

  (** Creates a {!Result.t} node of type {!Token_type.t.Comment}. 

      Arguments:
      - A list of commentary lines (strings) from the original file.

      Returns: a {!Result.t} record.

      For example, [create ["Comment line 1"; "comment line 2";]] will 
      create a {!Result.t} node consisting of the two provided lines
      of commentary. *)
  val create : string list -> t

end

(** Helps construct {!Token_type.t.Code} results. *)
module Code : sig

  (** Creates a {!Result.t} node of type {!Token_type.t.Code}. 

      Arguments:
      - A list of the raw contents/data (i.e., lines (strings) from 
      the original file).
      - A command (a string) to execute in a shell.
      - Any output (a list of strings) the command is expected to produce.

      Returns: a {!Result.t} record.

      For example, [create ["echo hello"] ["hello"]] says to execute
      the command [echo hello], and to expect the ouptut to be [hello].
      So, this function will execute the command [echo hello], capture 
      its exit code, stdout, and stderr, and so on, check that it matches
      the expected output [hello], and finally, it will return a {!Result.t}
      record with all that information.

      Note that there need not be any expected output. The expected output
      can be an empty list [[]]. *)
  val create : string list -> string -> string list -> t

end

(** Helps construct {!Token_type.t.ProfiledCode} results. *)
module ProfiledCode : sig

  (** Creates a {!Result.t} node of type {!Token_type.t.ProfiledCode}.
      A result of type {!Token_type.t.ProfiledCode} is just like a result
      for {!Token_type.t.Code}, except this function will profile the command
      it executes. That is, it will run the command a number of times and
      compute its avg running time. These results are added to the resulting
      {!Result.t} record as the [trials] field.

      Arguments:
      - A list of the raw contents/data (i.e., lines (strings) from 
      the original file).
      - A command (a string) to execute in a shell.
      - Any output (a list of strings) the command is expected to produce.

      Returns: a {!Result.t} record. 

      For examples, see {Result.Code.create}. *)
  val create : string list -> string -> string list -> int -> t

end

(** Helps construct {!Token_type.t.Stats} results. *)
module Stats : sig

  (** Creates a {!Result.t} node of type {!Token_type.t.Stats}.

      Arguments:
      - A list of the raw contents/data (i.e., lines (strings) from 
      the original file). This should really just contain
      the one string ["#stats"]. 

      Returns: a {!Result.t} record. 

      Note that there is nothing to evaluate in a stats node. There
      are stats to print, but that is done by the {!Printer} at the
      time of printing to the screen. So {!Result.t} records for
      stats really just contain the string [#stats], much like how
      {!Result.t} records for comment lines just contain the comment
      lines. *)
  val create : string list -> t

end

(** Helps construct {!Token_type.t.Diff} results. *)
module Diff : sig

  (** Creates a {!Result.t} node of type {!Token_type.t.Diff}.

      Arguments:
      - A list of the raw contents/data (i.e., lines (strings) from 
      the original file). This should really just contain
      the one string ["#diff"]. 

      Returns: a {!Result.t} record. 

      Note that there is nothing to evaluate in a diff node. There
      is a diff to print, but that is done by the {!Printer} at the
      time of printing to the screen. Like a {!Result.t} record for
      stats or commentary, this type of result only contains
      the string [#diff]. *)
  val create : string list -> t

end