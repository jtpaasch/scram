(** Implements {!Result_printer}. *)

let marshal_result r =
  let tk_type = Token_type.string_of (Result.token r) in
  let tk_type_str = Printf.sprintf "Token type: %s" tk_type in
  let tk_type_ttystr = Tty_str.create tk_type_str in

  let lines_header = Tty_str.create "Raw data:" in
  let lines = List.map (Printf.sprintf "- %s") (Result.data r) in
  let lines_ttystrs = List.map Tty_str.create lines in

  let cmd =
    match Result.cmd r with
    | None -> "Cmd: N/a"
    | Some x -> Printf.sprintf "Cmd: %s" x in
  let cmd_ttystr = Tty_str.create cmd in

  let output_header =
    match Result.output r with
    | None -> Tty_str.create "Expected output: N/a"
    | Some x -> Tty_str.create "Expected output:" in
  let output =
    match Result.output r with
    | None -> []
    | Some x ->
      match List.length x with
      | 0 -> ["- None specified"]
      | _ -> List.map (Printf.sprintf "- %s") x in
  let output_ttystrs = List.map Tty_str.create output in

  let stdout_header =
    match Result.stdout r with
    | None -> Tty_str.create "Captured stdout: N/a"
    | Some x -> Tty_str.create "Captured stdout:" in
  let stdout_data =
    match Result.stdout r with
    | None -> []
    | Some x ->
      match List.length x with
      | 0 -> ["- None captured"]
      | _ -> List.map (Printf.sprintf "- %s") x in
  let stdout_ttystrs = List.map Tty_str.create stdout_data in

  let stderr_header =
    match Result.stderr r with
    | None -> Tty_str.create "Captured stderr: N/a"
    | Some x -> Tty_str.create "Captured stderr:" in
  let stderr_data =
    match Result.stderr r with
    | None -> []
    | Some x ->
      match List.length x with
      | 0 -> ["- None captured"]
      | _ -> List.map (Printf.sprintf "- %s") x in
  let stderr_ttystrs = List.map Tty_str.create stderr_data in

  let exit_code =
    match Result.exit_code r with
    | None -> "Exit code: N/a"
    | Some x -> Printf.sprintf "Exit code: %d" x in
  let exit_code_ttystr = Tty_str.create exit_code in

  let pass, reason =
    let is_success = Success.is_successful (Result.success r) in
    let why = Success.why (Result.success r) in
    match (is_success, why) with
    | (true, stat) -> ("Passed", Success.string_of_why stat)
    | (false, stat) -> ("Failed", Success.string_of_why stat) in
  let success = Printf.sprintf "Test result: %s (%s)" pass reason in
  let success_ttystr = Tty_str.create success in

  let trials_header = 
    match Result.trials r with
    | None -> "Trials: N/a"
    | Some x -> "Trials:" in
  let trials_header_ttystr = Tty_str.create trials_header in

  let trials =
    match Result.trials r with
    | None -> []
    | Some x -> Trials_printer.pprint x in
  let trials_ttystr = List.map Tty_str.create trials in

  let footer = Tty_str.create "" in
  List.flatten [[tk_type_ttystr]; [lines_header]; lines_ttystrs;
    [cmd_ttystr]; [output_header]; output_ttystrs; [stdout_header];
    stdout_ttystrs; [stderr_header]; stderr_ttystrs; [exit_code_ttystr];
    [trials_header_ttystr]; trials_ttystr; 
    [success_ttystr]; [footer]]

(** Generate a {!Tty_str.t} list from a {!Result.t} list.

    Arguments:
    - A {!Result.t} list (e.g., generated by {!Eval.run}).

    Returns: a {!Tty_str.t} list. *)
let pprint results =
  let header =
    Tty_str.create ~fmt:Tty_str.Bold 
    "---------------- Execution Results\n" in
  let results_output = List.map marshal_result results in
  let results_ttystrs = List.flatten results_output in
  List.flatten [[header]; results_ttystrs]
